#include <uvgrtp/lib.hh>

extern "C" {
#include <libavcodec/avcodec.h>
#include <libavutil/imgutils.h>
#include <libswscale/swscale.h>
}

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <functional>
#include <iostream>
#include <memory>
#include <regex>
#include <string>
#include <thread>
#include <vector>

namespace fs = std::filesystem;

struct ProgramOptions {
    std::string input_dir = ".";
    std::string pattern = "frame_*.png";
    std::string ip = "239.0.2.3";
    uint16_t port = 2304;
    int fps = 30;
    int bitrate = 1'000'000;
    int gop = 30;
    int max_frames = -1;
    bool verbose = false;

    static void print_help(const char* argv0)
    {
        std::cerr << "Usage: " << argv0 << " [options]\n"
                  << "  --input DIR           Input folder (default: .)\n"
                  << "  --pattern GLOB        Pattern like frame_*.png (default: frame_*.png)\n"
                  << "  --ip IP               Destination IP (default: 239.0.2.3)\n"
                  << "  --port N              Destination port (default: 2304)\n"
                  << "  --fps N               FPS (default: 30)\n"
                  << "  --bitrate N           Bitrate in bps (default: 1000000)\n"
                  << "  --gop N               GOP size / keyint (default: 30)\n"
                  << "  --max-frames N        Max frames to process (default: all)\n"
                  << "  --verbose | -v        Verbose logging\n"
                  << "  -h | --help           This help\n";
    }

    bool parse(int argc, char** argv)
    {
        for (int i = 1; i < argc; ++i) {
            std::string a = argv[i];
            auto need = [&](const char* name) -> bool {
                if (i + 1 >= argc) {
                    std::cerr << name << " requires a value\n";
                    return false;
                }
                return true;
            };
            if (a == "--input") {
                if (!need("--input"))
                    return false;
                input_dir = argv[++i];
            } else if (a == "--pattern") {
                if (!need("--pattern"))
                    return false;
                pattern = argv[++i];
            } else if (a == "--ip") {
                if (!need("--ip"))
                    return false;
                ip = argv[++i];
            } else if (a == "--port") {
                if (!need("--port"))
                    return false;
                port = static_cast<uint16_t>(std::stoi(argv[++i]));
            } else if (a == "--fps") {
                if (!need("--fps"))
                    return false;
                fps = std::stoi(argv[++i]);
            } else if (a == "--bitrate") {
                if (!need("--bitrate"))
                    return false;
                bitrate = std::stoi(argv[++i]);
            } else if (a == "--gop") {
                if (!need("--gop"))
                    return false;
                gop = std::stoi(argv[++i]);
            } else if (a == "--max-frames") {
                if (!need("--max-frames"))
                    return false;
                max_frames = std::stoi(argv[++i]);
            } else if (a == "--verbose" || a == "-v") {
                verbose = true;
            } else if (a == "-h" || a == "--help") {
                print_help(argv[0]);
                return false;
            } else {
                std::cerr << "Unknown arg: " << a << "\n";
                print_help(argv[0]);
                return false;
            }
        }
        if (fps <= 0) {
            std::cerr << "fps must be > 0\n";
            return false;
        }
        if (bitrate <= 0) {
            std::cerr << "bitrate must be > 0\n";
            return false;
        }
        if (gop <= 0) {
            std::cerr << "gop must be > 0\n";
            return false;
        }
        return true;
    }
};

static std::regex glob_to_regex(const std::string& pat)
{
    std::string rx;
    rx.reserve(pat.size() * 2);
    for (char c : pat) {
        switch (c) {
        case '*':
            rx += ".*";
            break;
        case '?':
            rx += '.';
            break;
        case '.':
            rx += "\\.";
            break;
        default:
            rx += c;
            break;
        }
    }
    return std::regex("^" + rx + "$", std::regex::ECMAScript | std::regex::icase);
}

static bool looks_annexb(const uint8_t* p, int n)
{
    if (n >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0 && p[3] == 1)
        return true;
    if (n >= 3 && p[0] == 0 && p[1] == 0 && p[2] == 1)
        return true;
    return false;
}

struct AVCodecContextDel {
    void operator()(AVCodecContext* c) const
    {
        if (c)
            avcodec_free_context(&c);
    }
};
struct AVFrameDel {
    void operator()(AVFrame* f) const
    {
        if (f)
            av_frame_free(&f);
    }
};
struct AVPacketDel {
    void operator()(AVPacket* p) const
    {
        if (p)
            av_packet_free(&p);
    }
};
struct SwsContextDel {
    void operator()(SwsContext* s) const
    {
        if (s)
            sws_freeContext(s);
    }
};
struct AVBSFContextDel {
    void operator()(AVBSFContext* b) const
    {
        if (b)
            av_bsf_free(&b);
    }
};

struct SPSPPS {
    std::vector<uint8_t> sps, pps;
    int nal_len_size = 4;
};

static SPSPPS parse_avcc_extradata(const AVCodecContext* c)
{
    SPSPPS out;
    if (!c || !c->extradata || c->extradata_size < 7)
        return out;
    const uint8_t* e = c->extradata;
    int n = c->extradata_size;
    if (e[0] != 1)
        return out;
    out.nal_len_size = (e[4] & 0x3) + 1;
    int pos = 5;
    int num_sps = e[pos++] & 0x1F;
    for (int i = 0; i < num_sps; ++i) {
        if (pos + 2 > n)
            break;
        int len = (e[pos] << 8) | e[pos + 1];
        pos += 2;
        if (pos + len > n)
            break;
        out.sps.assign(e + pos, e + pos + len);
        pos += len;
    }
    if (pos >= n)
        return out;
    int num_pps = e[pos++];
    for (int i = 0; i < num_pps; ++i) {
        if (pos + 2 > n)
            break;
        int len = (e[pos] << 8) | e[pos + 1];
        pos += 2;
        if (pos + len > n)
            break;
        out.pps.assign(e + pos, e + pos + len);
        pos += len;
    }
    return out;
}

static void avcc_payload_to_annexb(const uint8_t* in, int in_size, int nal_len_size, std::vector<uint8_t>& out)
{
    out.clear();
    int i = 0;
    auto push_sc = [&] {
        out.insert(out.end(), {0, 0, 0, 1});
    };
    while (i + nal_len_size <= in_size) {
        uint32_t nal_len = 0;
        for (int k = 0; k < nal_len_size; ++k)
            nal_len = (nal_len << 8) | in[i + k];
        i += nal_len_size;
        if (nal_len == 0 || i + static_cast<int>(nal_len) > in_size)
            break;
        push_sc();
        out.insert(out.end(), in + i, in + i + nal_len);
        i += nal_len;
    }
}

static void prepend_sps_pps(std::vector<uint8_t>& au, const SPSPPS& hp)
{
    if (hp.sps.empty() || hp.pps.empty())
        return;
    std::vector<uint8_t> out;
    const uint8_t sc[4] = {0, 0, 0, 1};
    out.insert(out.end(), sc, sc + 4);
    out.insert(out.end(), hp.sps.begin(), hp.sps.end());
    out.insert(out.end(), sc, sc + 4);
    out.insert(out.end(), hp.pps.begin(), hp.pps.end());
    out.insert(out.end(), au.begin(), au.end());
    au.swap(out);
}

struct EncodedAU {
    std::vector<uint8_t> bytes;
    int64_t pts = 0;
    bool key = false;
};

class Encoder {
public:
    Encoder() = default;
    ~Encoder() = default;

    bool init(int w, int h, int fps, int bitrate, int gop, bool verbose)
    {
        verbose_ = verbose;

        const AVCodec* codec = avcodec_find_encoder_by_name("libx264");
        if (!codec)
            codec = avcodec_find_encoder(AV_CODEC_ID_H264);
        if (!codec) {
            std::cerr << "No H.264 encoder found\n";
            return false;
        }

        ctx_.reset(avcodec_alloc_context3(codec));
        if (!ctx_) {
            std::cerr << "avcodec_alloc_context3 failed\n";
            return false;
        }

        ctx_->width = w;
        ctx_->height = h;
        ctx_->time_base = AVRational { 1, fps };
        ctx_->framerate = AVRational { fps, 1 };
        ctx_->pix_fmt = AV_PIX_FMT_YUV420P;
        ctx_->gop_size = gop;
        ctx_->max_b_frames = 0;
        ctx_->bit_rate = bitrate;
        ctx_->flags &= ~AV_CODEC_FLAG_GLOBAL_HEADER;

        av_opt_set(ctx_->priv_data, "preset", "veryfast", 0);
        av_opt_set(ctx_->priv_data, "tune", "zerolatency", 0);
        av_opt_set(ctx_->priv_data, "repeat-headers", "1", 0);

        if (avcodec_open2(ctx_.get(), codec, nullptr) < 0) {
            std::cerr << "avcodec_open2 failed\n";
            return false;
        }

        frame_.reset(av_frame_alloc());
        frame_->format = ctx_->pix_fmt;
        frame_->width = w;
        frame_->height = h;
        if (av_frame_get_buffer(frame_.get(), 32) < 0) {
            std::cerr << "av_frame_get_buffer failed\n";
            return false;
        }

        sws_.reset(sws_getContext(w, h, AV_PIX_FMT_BGR24, w, h, AV_PIX_FMT_YUV420P, SWS_BILINEAR, nullptr, nullptr, nullptr));
        if (!sws_) {
            std::cerr << "sws_getContext failed\n";
            return false;
        }

        const AVBitStreamFilter* f = av_bsf_get_by_name("h264_mp4toannexb");
        if (f) {
            AVBSFContext* raw = nullptr;
            if (av_bsf_alloc(f, &raw) < 0) {
                std::cerr << "av_bsf_alloc failed\n";
                return false;
            }
            bsf_.reset(raw);
            if (avcodec_parameters_from_context(bsf_->par_in, ctx_.get()) < 0) {
                std::cerr << "avcodec_parameters_from_context failed\n";
                return false;
            }
            if (av_bsf_init(bsf_.get()) < 0) {
                std::cerr << "av_bsf_init failed\n";
                return false;
            }
            use_bsf_ = true;
        } else {
            hp_ = parse_avcc_extradata(ctx_.get());
            use_bsf_ = false;
            if (verbose_) {
                std::cerr << "[warn] BSF not found; using AVCC->AnnexB fallback\n";
            }
        }

        return true;
    }

    bool encode(const cv::Mat& bgr, std::vector<EncodedAU>& out_collector, int64_t pts)
    {
        if (bgr.cols != ctx_->width || bgr.rows != ctx_->height || bgr.channels() != 3) {
            std::cerr << "encode: unexpected frame shape\n";
            return false;
        }

        if (av_frame_make_writable(frame_.get()) < 0) {
            std::cerr << "frame not writable\n";
            return false;
        }

        const uint8_t* src[1] = { bgr.data };
        int src_stride[1] = { static_cast<int>(bgr.step[0]) };
        sws_scale(sws_.get(), src, src_stride, 0, ctx_->height, frame_->data, frame_->linesize);

        frame_->pts = pts;

        if (int e = avcodec_send_frame(ctx_.get(), frame_.get()); e < 0) {
            std::cerr << "avcodec_send_frame: " << e << "\n";
            return false;
        }

        while (true) {
            std::unique_ptr<AVPacket, AVPacketDel> pkt(av_packet_alloc());
            int r = avcodec_receive_packet(ctx_.get(), pkt.get());
            if (r == AVERROR(EAGAIN) || r == AVERROR_EOF)
                break;
            if (r < 0) {
                std::cerr << "avcodec_receive_packet: " << r << "\n";
                return false;
            }

            if (use_bsf_) {
                if (av_bsf_send_packet(bsf_.get(), pkt.get()) < 0) {
                    std::cerr << "bsf_send failed\n";
                    return false;
                }
                av_packet_unref(pkt.get());

                while (true) {
                    std::unique_ptr<AVPacket, AVPacketDel> out(av_packet_alloc());
                    int br = av_bsf_receive_packet(bsf_.get(), out.get());
                    if (br == AVERROR(EAGAIN) || br == AVERROR_EOF)
                        break;
                    if (br < 0) {
                        std::cerr << "bsf_receive failed\n";
                        return false;
                    }

                    EncodedAU au;
                    au.bytes.assign(out->data, out->data + out->size);
                    au.pts = out->pts;
                    au.key = (out->flags & AV_PKT_FLAG_KEY) != 0;
                    out_collector.emplace_back(std::move(au));
                }
            } else {
                EncodedAU au;
                if (looks_annexb(pkt->data, pkt->size)) {
                    au.bytes.assign(pkt->data, pkt->data + pkt->size);
                } else {
                    avcc_payload_to_annexb(pkt->data, pkt->size, hp_.nal_len_size, au.bytes);
                }
                if ((pkt->flags & AV_PKT_FLAG_KEY) && !(hp_.sps.empty() || hp_.pps.empty())) {
                    prepend_sps_pps(au.bytes, hp_);
                }
                au.pts = pkt->pts;
                au.key = (pkt->flags & AV_PKT_FLAG_KEY) != 0;
                out_collector.emplace_back(std::move(au));
            }
        }
        return true;
    }

    bool flush(std::vector<EncodedAU>& out_collector)
    {
        if (avcodec_send_frame(ctx_.get(), nullptr) < 0)
            return false;
        while (true) {
            std::unique_ptr<AVPacket, AVPacketDel> pkt(av_packet_alloc());
            int r = avcodec_receive_packet(ctx_.get(), pkt.get());
            if (r == AVERROR(EAGAIN) || r == AVERROR_EOF)
                break;
            if (r < 0) {
                std::cerr << "flush receive_packet: " << r << "\n";
                return false;
            }

            if (use_bsf_) {
                if (av_bsf_send_packet(bsf_.get(), pkt.get()) < 0)
                    return false;
                av_packet_unref(pkt.get());
                while (true) {
                    std::unique_ptr<AVPacket, AVPacketDel> out(av_packet_alloc());
                    int br = av_bsf_receive_packet(bsf_.get(), out.get());
                    if (br == AVERROR(EAGAIN) || br == AVERROR_EOF)
                        break;
                    if (br < 0)
                        return false;

                    EncodedAU au;
                    au.bytes.assign(out->data, out->data + out->size);
                    au.pts = out->pts;
                    au.key = (out->flags & AV_PKT_FLAG_KEY) != 0;
                    out_collector.emplace_back(std::move(au));
                }
            } else {
                EncodedAU au;
                if (looks_annexb(pkt->data, pkt->size)) {
                    au.bytes.assign(pkt->data, pkt->data + pkt->size);
                } else {
                    avcc_payload_to_annexb(pkt->data, pkt->size, hp_.nal_len_size, au.bytes);
                }
                if ((pkt->flags & AV_PKT_FLAG_KEY) && !(hp_.sps.empty() || hp_.pps.empty())) {
                    prepend_sps_pps(au.bytes, hp_);
                }
                au.pts = pkt->pts;
                au.key = (pkt->flags & AV_PKT_FLAG_KEY) != 0;
                out_collector.emplace_back(std::move(au));
            }
        }
        return true;
    }

    AVRational time_base() const { return ctx_->time_base; }
    int width() const { return ctx_->width; }
    int height() const { return ctx_->height; }

private:
    bool verbose_ = false;
    std::unique_ptr<AVCodecContext, AVCodecContextDel> ctx_;
    std::unique_ptr<AVFrame, AVFrameDel> frame_;
    std::unique_ptr<SwsContext, SwsContextDel> sws_;
    std::unique_ptr<AVBSFContext, AVBSFContextDel> bsf_;
    bool use_bsf_ = false;
    SPSPPS hp_;
};

static bool load_and_preprocess(const ProgramOptions& opt, std::vector<cv::Mat>& frames_out, int&
